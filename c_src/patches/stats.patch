diff --git embedded_innodb-1.0.3.5325.orig/api/api0api.c embedded_innodb-1.0.3.5325/api/api0api.c
index a934273..6f3cb5e 100644
--- embedded_innodb-1.0.3.5325.orig/api/api0api.c
+++ embedded_innodb-1.0.3.5325/api/api0api.c
@@ -6404,3 +6404,66 @@ ib_strerror(
 	/* NOT REACHED */
 	return("Unknown error");
 }
+
+/*****************************************************************
+Return current statistics. */
+
+#define COPY(X) ib_status_vars->X = export_vars.X
+
+void
+ib_get_status_vars(
+/*==========*/
+        ib_status_vars_t*	ib_status_vars)   /* upd: statistics structure */
+{
+    /* Pull the stats into the export structure */
+    srv_export_innodb_status();
+
+    /* Copy across the stats one by one */
+    COPY(innodb_data_pending_reads);
+    COPY(innodb_data_pending_writes);
+    COPY(innodb_data_pending_fsyncs);
+    COPY(innodb_data_fsyncs);
+    COPY(innodb_data_read);
+    COPY(innodb_data_writes);
+    COPY(innodb_data_written);
+    COPY(innodb_data_reads);
+    COPY(innodb_buffer_pool_pages_total);
+    COPY(innodb_buffer_pool_pages_data);
+    COPY(innodb_buffer_pool_pages_dirty);
+    COPY(innodb_buffer_pool_pages_misc);
+    COPY(innodb_buffer_pool_pages_free);
+#ifdef UNIV_DEBUG
+    COPY(innodb_buffer_pool_pages_latched);
+#endif /* UNIV_DEBUG */
+    COPY(innodb_buffer_pool_read_requests);
+    COPY(innodb_buffer_pool_reads);
+    COPY(innodb_buffer_pool_wait_free);
+    COPY(innodb_buffer_pool_pages_flushed);
+    COPY(innodb_buffer_pool_write_requests);
+    COPY(innodb_buffer_pool_read_ahead_seq);
+    COPY(innodb_buffer_pool_read_ahead_rnd);
+    COPY(innodb_dblwr_pages_written);
+    COPY(innodb_dblwr_writes);
+    COPY(innodb_log_waits);
+    COPY(innodb_log_write_requests);
+    COPY(innodb_log_writes);
+    COPY(innodb_os_log_written);
+    COPY(innodb_os_log_fsyncs);
+    COPY(innodb_os_log_pending_writes);
+    COPY(innodb_os_log_pending_fsyncs);
+    COPY(innodb_page_size);
+    COPY(innodb_pages_created);
+    COPY(innodb_pages_read);
+    COPY(innodb_pages_written);
+    COPY(innodb_row_lock_waits);
+    COPY(innodb_row_lock_current_waits);
+    COPY(innodb_row_lock_time);
+    COPY(innodb_row_lock_time_avg);
+    COPY(innodb_row_lock_time_max);
+    COPY(innodb_rows_read);
+    COPY(innodb_rows_inserted);
+    COPY(innodb_rows_updated);
+    COPY(innodb_rows_deleted);
+}
+
+#undef COPY
diff --git embedded_innodb-1.0.3.5325.orig/include/api0api.h embedded_innodb-1.0.3.5325/include/api0api.h
index 6cb942f..a1f9958 100644
--- embedded_innodb-1.0.3.5325.orig/include/api0api.h
+++ embedded_innodb-1.0.3.5325/include/api0api.h
@@ -37,6 +37,7 @@ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 typedef enum db_err             ib_err_t;
 typedef unsigned char           ib_byte_t;
 typedef unsigned long int       ib_ulint_t;
+typedef long long               ib_llong_t;
 typedef void*                   ib_opaque_t;
 /* Ideally we would like to have this as ib_byte_t, but we need to make it
 the same as the InnoDB internal ibool. */
@@ -249,6 +250,55 @@ typedef enum ib_trx_level_enum {
 					LOCK IN SHARE MODE reads */
 } ib_trx_level_t;
 
+/* In this structure we store status variables to be passed to the client. */
+typedef struct ib_status_vars_t {
+	ib_ulint_t innodb_data_pending_reads;
+	ib_ulint_t innodb_data_pending_writes;
+	ib_ulint_t innodb_data_pending_fsyncs;
+	ib_ulint_t innodb_data_fsyncs;
+	ib_ulint_t innodb_data_read;
+	ib_ulint_t innodb_data_writes;
+	ib_ulint_t innodb_data_written;
+	ib_ulint_t innodb_data_reads;
+	ib_ulint_t innodb_buffer_pool_pages_total;
+	ib_ulint_t innodb_buffer_pool_pages_data;
+	ib_ulint_t innodb_buffer_pool_pages_dirty;
+	ib_ulint_t innodb_buffer_pool_pages_misc;
+	ib_ulint_t innodb_buffer_pool_pages_free;
+#ifdef UNIV_DEBUG
+	ib_ulint_t innodb_buffer_pool_pages_latched;
+#endif /* UNIV_DEBUG */
+	ib_ulint_t innodb_buffer_pool_read_requests;
+	ib_ulint_t innodb_buffer_pool_reads;
+	ib_ulint_t innodb_buffer_pool_wait_free;
+	ib_ulint_t innodb_buffer_pool_pages_flushed;
+	ib_ulint_t innodb_buffer_pool_write_requests;
+	ib_ulint_t innodb_buffer_pool_read_ahead_seq;
+	ib_ulint_t innodb_buffer_pool_read_ahead_rnd;
+	ib_ulint_t innodb_dblwr_pages_written;
+	ib_ulint_t innodb_dblwr_writes;
+	ib_ulint_t innodb_log_waits;
+	ib_ulint_t innodb_log_write_requests;
+	ib_ulint_t innodb_log_writes;
+	ib_ulint_t innodb_os_log_written;
+	ib_ulint_t innodb_os_log_fsyncs;
+	ib_ulint_t innodb_os_log_pending_writes;
+	ib_ulint_t innodb_os_log_pending_fsyncs;
+	ib_ulint_t innodb_page_size;
+	ib_ulint_t innodb_pages_created;
+	ib_ulint_t innodb_pages_read;
+	ib_ulint_t innodb_pages_written;
+	ib_ulint_t innodb_row_lock_waits;
+	ib_ulint_t innodb_row_lock_current_waits;
+	ib_llong_t innodb_row_lock_time;
+	ib_ulint_t innodb_row_lock_time_avg;
+	ib_ulint_t innodb_row_lock_time_max;
+	ib_ulint_t innodb_rows_read;
+	ib_ulint_t innodb_rows_inserted;
+	ib_ulint_t innodb_rows_updated;
+	ib_ulint_t innodb_rows_deleted;
+} ib_status_vars_t;
+
 /* Generical InnoDB callback prototype. */
 typedef void (*ib_cb_t)(void);
 
@@ -1536,6 +1586,14 @@ ib_strerror(
 				/* out: string, describing the error */
 	ib_err_t	num);	/* in: error number */
 
+/*****************************************************************
+Return current statistics. */
+void
+ib_get_status_vars(
+/*==========*/
+        ib_status_vars_t*	ib_status_vars);   /* upd: statistics structure */
+
+
 /* API_END_INCLUDE */
 #include <stdarg.h>
 
diff --git embedded_innodb-1.0.3.5325.orig/include/ib0config.h embedded_innodb-1.0.3.5325/include/ib0config.h
index 326a16e..cb529db 100644
--- embedded_innodb-1.0.3.5325.orig/include/ib0config.h
+++ embedded_innodb-1.0.3.5325/include/ib0config.h
@@ -14,7 +14,7 @@
 
 /* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
    */
-/* #undef HAVE_ALLOCA_H */
+#define HAVE_ALLOCA_H 1
 
 /* Define to 1 if you have the <assert.h> header file. */
 #define HAVE_ASSERT_H 1
@@ -60,7 +60,7 @@
 #define HAVE_FCNTL_H 1
 
 /* Define to 1 if you have the `finite' function. */
-/* #undef HAVE_FINITE */
+#define HAVE_FINITE 1
 
 /* Define to 1 if you have the `fsync' function. */
 #define HAVE_FSYNC 1
@@ -168,7 +168,7 @@
 #define HAVE_RENAME 1
 
 /* Define to 1 if you have the `rint' function. */
-/* #undef HAVE_RINT */
+#define HAVE_RINT 1
 
 /* Define to 1 if you have the <sched.h> header file. */
 #define HAVE_SCHED_H 1
@@ -315,7 +315,7 @@
 #define HAVE_U_INT32_T 1
 
 /* Define to 1 if you have the <valgrind/memcheck.h> header file. */
-/* #undef HAVE_VALGRIND_MEMCHECK_H */
+#define HAVE_VALGRIND_MEMCHECK_H 1
 
 /* Define to 1 if you have the <zlib.h> header file. */
 #define HAVE_ZLIB_H 1
@@ -363,13 +363,13 @@
 #define SIZEOF_CHAR 1
 
 /* The size of `char*', as computed by sizeof. */
-#define SIZEOF_CHARP 8
+#define SIZEOF_CHARP 4
 
 /* The size of `int', as computed by sizeof. */
 #define SIZEOF_INT 4
 
 /* The size of `long', as computed by sizeof. */
-#define SIZEOF_LONG 8
+#define SIZEOF_LONG 4
 
 /* The size of `long long', as computed by sizeof. */
 #define SIZEOF_LONG_LONG 8
@@ -378,13 +378,13 @@
 #define SIZEOF_OFF_T 8
 
 /* Size of the "pthread_t" type */
-#define SIZEOF_PTHREAD_T 8
+#define SIZEOF_PTHREAD_T 4
 
 /* The size of `short', as computed by sizeof. */
 #define SIZEOF_SHORT 2
 
 /* The size of `void*', as computed by sizeof. */
-#define SIZEOF_VOIDP 8
+#define SIZEOF_VOIDP 4
 
 /* If using the C implementation of alloca, define if you know the
    direction of stack growth for your system; otherwise it will be
diff --git embedded_innodb-1.0.3.5325.orig/innodb.h embedded_innodb-1.0.3.5325/innodb.h
index deb5ca2..05dbdb1 100644
--- embedded_innodb-1.0.3.5325.orig/innodb.h
+++ embedded_innodb-1.0.3.5325/innodb.h
@@ -128,6 +128,7 @@ enum db_err {
 typedef enum db_err             ib_err_t;
 typedef unsigned char           ib_byte_t;
 typedef unsigned long int       ib_ulint_t;
+typedef long long               ib_llong_t;
 typedef void*                   ib_opaque_t;
 /* Ideally we would like to have this as ib_byte_t, but we need to make it
 the same as the InnoDB internal ibool. */
@@ -136,7 +137,7 @@ typedef ib_opaque_t             ib_charset_t;
 
 /* We assume C99 support except when using VisualStudio. */
 #if !defined(_MSC_VER)
-#include <stdint.h>		
+#include <stdint.h>
 #endif /* _MSC_VER */
 
 /* Integer types used by the API. Microsft VS defines its own types
@@ -264,13 +265,13 @@ typedef enum ib_lck_mode_enum {
 	IB_LOCK_NUM = IB_LOCK_NONE	/* number of lock modes */
 } ib_lck_mode_t;
 
-/* InnoDB cursor search modes for ib_cursor_moveto(). 
+/* InnoDB cursor search modes for ib_cursor_moveto().
 Note: Valies must match those found in page0cur.h */
 typedef enum ib_srch_mode_enum {
 	IB_CUR_G = 1,			/* If search key is not found then
 					position the cursor on the row that
-				       	is greater than the search key */
-	IB_CUR_GE = 2,			/* If the search key not found then 
+					is greater than the search key */
+	IB_CUR_GE = 2,			/* If the search key not found then
 					position the cursor on the row that
 					is greater than or equal to the search
 					key */
@@ -287,7 +288,7 @@ typedef enum ib_srch_mode_enum {
 typedef enum ib_match_mode_enum {
 	IB_CLOSEST_MATCH,		/* Closest match possible */
 	IB_EXACT_MATCH,			/* Search using a complete key value */
-	IB_EXACT_PREFIX			/* Search using a key prefix which	
+	IB_EXACT_PREFIX			/* Search using a key prefix which
 					must match to rows: the prefix may
 					contain an incomplete field (the
 					last field in prefix may be just
@@ -340,6 +341,55 @@ typedef enum ib_trx_level_enum {
 					LOCK IN SHARE MODE reads */
 } ib_trx_level_t;
 
+/* In this structure we store status variables to be passed to the client. */
+typedef struct ib_status_vars_t {
+	ib_ulint_t innodb_data_pending_reads;
+	ib_ulint_t innodb_data_pending_writes;
+	ib_ulint_t innodb_data_pending_fsyncs;
+	ib_ulint_t innodb_data_fsyncs;
+	ib_ulint_t innodb_data_read;
+	ib_ulint_t innodb_data_writes;
+	ib_ulint_t innodb_data_written;
+	ib_ulint_t innodb_data_reads;
+	ib_ulint_t innodb_buffer_pool_pages_total;
+	ib_ulint_t innodb_buffer_pool_pages_data;
+	ib_ulint_t innodb_buffer_pool_pages_dirty;
+	ib_ulint_t innodb_buffer_pool_pages_misc;
+	ib_ulint_t innodb_buffer_pool_pages_free;
+#ifdef UNIV_DEBUG
+	ib_ulint_t innodb_buffer_pool_pages_latched;
+#endif /* UNIV_DEBUG */
+	ib_ulint_t innodb_buffer_pool_read_requests;
+	ib_ulint_t innodb_buffer_pool_reads;
+	ib_ulint_t innodb_buffer_pool_wait_free;
+	ib_ulint_t innodb_buffer_pool_pages_flushed;
+	ib_ulint_t innodb_buffer_pool_write_requests;
+	ib_ulint_t innodb_buffer_pool_read_ahead_seq;
+	ib_ulint_t innodb_buffer_pool_read_ahead_rnd;
+	ib_ulint_t innodb_dblwr_pages_written;
+	ib_ulint_t innodb_dblwr_writes;
+	ib_ulint_t innodb_log_waits;
+	ib_ulint_t innodb_log_write_requests;
+	ib_ulint_t innodb_log_writes;
+	ib_ulint_t innodb_os_log_written;
+	ib_ulint_t innodb_os_log_fsyncs;
+	ib_ulint_t innodb_os_log_pending_writes;
+	ib_ulint_t innodb_os_log_pending_fsyncs;
+	ib_ulint_t innodb_page_size;
+	ib_ulint_t innodb_pages_created;
+	ib_ulint_t innodb_pages_read;
+	ib_ulint_t innodb_pages_written;
+	ib_ulint_t innodb_row_lock_waits;
+	ib_ulint_t innodb_row_lock_current_waits;
+	ib_llong_t innodb_row_lock_time;
+	ib_ulint_t innodb_row_lock_time_avg;
+	ib_ulint_t innodb_row_lock_time_max;
+	ib_ulint_t innodb_rows_read;
+	ib_ulint_t innodb_rows_inserted;
+	ib_ulint_t innodb_rows_updated;
+	ib_ulint_t innodb_rows_deleted;
+} ib_status_vars_t;
+
 /* Generical InnoDB callback prototype. */
 typedef void (*ib_cb_t)(void);
 
@@ -1340,7 +1390,7 @@ following sequence of calls:
 	visitor->index() for each user index
 	visitor->index_col() for each column in user index
 
-It will stop if any of the above functions returns a non-zero value. 
+It will stop if any of the above functions returns a non-zero value.
 The caller must have an exclusive lock on the InnoDB data dictionary */
 
 ib_err_t
@@ -1348,7 +1398,7 @@ ib_table_schema_visit(
 /*==================*/
 					/* out: DB_SUCCESS or DB_ERROR */
 	ib_trx_t			ib_trx,
-					/* in: transaction that 
+					/* in: transaction that
 					owns the schema lock */
 	const char*		name,	/* in: table name to read */
 	const ib_schema_visitor_t*	/* in: visitor functions */
@@ -1358,8 +1408,8 @@ ib_table_schema_visit(
 
 /*********************************************************************
 List all the tables in the InnoDB's data dictionary. It will abort
-if visitor returns a non-zero value. 
- 
+if visitor returns a non-zero value.
+
 It will call the function:
 	visitor.tables(arg, const char* name, int name_len);
 
@@ -1368,7 +1418,7 @@ The function will abort if visitor.tables() returns non-zero. */
 ib_err_t
 ib_schema_tables_iterate(
 /*=====================*/
-	ib_trx_t		ib_trx,	/* in: transaction that 
+	ib_trx_t		ib_trx,	/* in: transaction that
 					owns the schema lock */
 	ib_schema_visitor_table_all_t
 				visitor,/* in: visitor function */
@@ -1627,6 +1677,14 @@ ib_strerror(
 				/* out: string, describing the error */
 	ib_err_t	num);	/* in: error number */
 
+/*****************************************************************
+Return current statistics. */
+void
+ib_get_status_vars(
+/*==========*/
+        ib_status_vars_t*	ib_status_vars);   /* upd: statistics structure */
+
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif /* __cplusplus */
